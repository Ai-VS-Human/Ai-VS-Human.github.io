---
title:  "자바 정리  중요합니다"

excerpt: " 햇갈리던 자바 용어들  "

categories: JAVA

date: 2023-02-12 22:08:00 +0900

---

## void 인경우 :
System.out.println() 메서드의 경우, 콘솔에 출력하고 끝나기 때문에 반환값이 없습니다. 따라서 이 메서드를 호출하여 콘솔에 출력된 결과를 다시 다른 변수에 저장할 수는 없습니다.   

반환값이없고 호출자에게 값을 반환하지않는다 > 출력결과물과 같다  
## void 가 아닌경우 :  
반면에, 다른 일반적인 메서드들은 반환값이 있을 수 있습니다. 예를 들어, Math.pow(x, y) 메서드는 x의 y제곱을 계산하여 그 값을 반환합니다. 이 경우에는 이 메서드를 호출하여 반환된 결과를 다른 변수에 저장할 수 있습니다.    

연산할떄 값을 계산후 그것을 호출자에게 값을 반환해주는것은 반환값이있다 즉 메모리에 올라가 저장되어있다   

----

# 멤버 : 
----
클래스내에 선언된   
변수,메서드 를 일컫는뜻   
(밑에것들은 다같은뜻이라고보면 된다)

----
멤버 : 멤버변수 ,멤버메서드 , 변수, 메서드 ,  iv, im cv,cm   같은말 이다   

----
iv,im : 인스턴스변수,인스턴스 메서드 , 객체    

---- 
cv ,cm : 클래스 변수 , 클래스 메서드 ,  static 정적,으로 선언되어야만 가능하다  (static은 iv ,im 을가질수없으며 클래스선언됨과 동시에 객체생성필요없이 사용가능하다 )  

# 생성자 (Constructor ):
----- 
생성자는 클래스명과같다 한번 호출하고끝이다

생성자는 객체를 생성하기 위한 특별한 메서드이다 ! 
생성자는 객체를 생성될때 호출된다 
객체의 초기화담당 , 
생성자는 객체를 반환하지않는다 
즉 메모리에 주소를 올라가있지않고(메모리주소를 가리키지않는다) 내가 호출할때만 쓰인다 


new 연산자는 메모리주소를 가르키기 때문 반환값이있다 (참조변수 , 메모리주소가 있다)

# 메서드 :

----

명령문들의 집합 ,함수라생각하면쉽다,어떠한기능을가진것 



# 오버라이딩 : 
-----
상속 : 하위클래스가 상위클래스의 멤버(변수(필드) ,메서드)를 받아 재정의하는것 
오버라이딩 : 상속받은 상위클래스 의 메서드를  하위클래스가 재정의해서 수정,하거나 메서드를 추가하는것 

상속: 기존 클래스를 확장해서 새로운 클래스를 만드는 것을 말합니다. 상속을 통해 기존 클래스의 코드를 재사용하고, 새로운 클래스에서 공통적인 기능을 구현할 수 있습니다. 상속을 받은 클래스는 상위 클래스의 멤버 변수 및 메서드를 그대로 사용할 수 있습니다.

오버라이딩: 상위 클래스에서 상속받은 메서드를 하위 클래스에서 재정의하는 것을 말합니다. 즉, 하위 클래스에서 상위 클래스의 메서드를 수정하거나 새롭게 구현하여 사용할 수 있습니다. 오버라이딩을 통해 하위 클래스에서 상위 클래스의 메서드를 수정할 수 있습니다.

두 개념 모두 객체 지향 프로그래밍에서 코드 재사용성을 높이기 위해 사용되며, 상속은 코드 중복을 방지하고 오버라이딩은 상위 클래스에서 정의된 메서드의 기능을 변경하여 다양한 경우에 맞게 사용할 수 있도록 합니다.

이는 객체 지향 프로그래밍의 다형성 특징 중 하나인 "상위 클래스의 참조 변수로 하위 클래스 객체를 다룰 수 있다"라는 특징 때문입니다. 즉, 상위 클래스의 메소드를 호출하는 코드가 있을 때, 해당 코드가 하위 클래스의 오버라이딩된 메소드를 실행하도록 보장하기 위해서는 하위 클래스에서 오버라이딩된 메소드의 접근 제어자가 상위 클래스에 정의된 메소드의 접근 제어자와 같거나 넓어야 합니다.

즉, 상속은 클래스 간의 계층 구조를 만들어서 코드를 재사용하는 것이고, 오버라이딩은 상위 클래스의 메서드를 하위 클래스에서 재정의하여 사용하는 것입니다. 둘 다 코드의 재사용성과 유지 보수성을 높이는데 중요한 역할을 합니다.

# 인터페이스 :
----

- 두 대상(객체) 간의 연결,대화,소통을 돕는 중간역할을 한다.  
- 선언(설계) 와 구현을 분리시킬수있게한다.  
선언 : 껍데기 (리모컨 + 컴퓨터본체뚜껑 , 추상메서드의집합 , 메서드선언부; ).  
구현 : 알맹이 (기능 , 로직 ,함수 , 메서드 , 몸통{} , 구현부 ). 

# 인터페이스의 장점 
컴퓨터의 껍데기의 버튼으로 우리가 쉽게 사용한다 . 우리는 내부기능(로직)을바꿔도 결국엔 껍데기가있어서 우리가 편안하게 사용한다   
컴퓨터의 내부 부품들을 교체했어도 > 우리는 컴퓨터 껍데기로 컴퓨터를 사용한다.  
내부를 인터페이스로 감싸놓는다.  
우리는 내부가바뀌어도 상관없다. 
인터페이스만 사용하니까   
  
A가 B에게 의존한다 > A가 B를 사용한다 강한결합.  
A > I(B) 를 사용한다 느슨한결합  I(인터페이스)는 안바뀐다 B(알맹이)는 자유자재로 바꿀쑤있다.  
알맹이를 인터페이스로 감싸놔야한다.  

# 인터페이스의장점 2 
개발 시간을 단축할수 있다     A > I 사용가능 B (A , B 동시에 개발가능 )    
뱐걍에 유리한 유연한 설계가능 느슨한결합.  A  > I(B) > I(C) 로 변경가능하다     
JDBC표준화가 가능하다  - JAVA > JDBC >  <(DB oracle , MYSQL).    데이터베이스를 바뀌어도 JDBC(인터페이스의집합) 표준화로 저쪽은 변경안해도된다     
서로 관계없는 클래스들을 관계를 맺어줄수있다.    
 
 

# 메서드 : 
() : 
메소드 호출 ();  
메소드 선언 (); 매개변수정의  
LV 지역변수존재 
메서드는 호출되면 사라진다 메서드내의 지역변수들보다 외부의 iv 가 더오래살아있다 .   

# 내부클래스 : 중요하다  

    public class Study { // main 클래스
      class Outer {
      }// 외부클래스
      인스턴스변수 iv
      스태틱 변수 cv

      static class StaticInner { 
      } //< 따로 객체생성안해도 바로사용가능 상시존재,상시사용가능

      class instanceInner {    // Outer oc = new Outer();    객체호출생성후 사용가능
        //Outer.instanceInner ii = oc.new instanceInner(); 객체호출생성후 사용가능
      }

      void myMethod();{// 
        지역변수 lv 
        class LocalInner{} //외부클래스의 지역메서드의안에 지역메서드내부 클래스이다   
        // 로컬클래스 안에서는 (StaticInner,instanceInner 사용불가) Outer사용가능 Method내의 지역변수 final 사용가능

      }
    }
    
    
>컴파일하면 내부클래스에서는 $ 이붙고 지역내부클래스는 $1 숫자가붙는다   

>메서드가 외부클래스에 위치할수도있고 , 내부클래스 안에 메서드가 존재할수도있다  

>메서드가 어디에 위치 에있는지 잘확인하는게중요하다 


#  메서드의 타입이없을땐 어떤걸가 ? 

반환값을 return 을 사용하려면 반환타입을 지정해줘야한다 

return 번환할려면  타입(int) 값이있어야한다 


